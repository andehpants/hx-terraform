/** Automatically @generated by gen-providers.ts, DO NOT EDIT */

import * as _ from "lodash";
import * as AT from "./types";
import * as TF from "../../core/core";

/**
 *  Provides attachment of a autoscaling group to a ALB load balancer
 *
 *  see https://www.terraform.io/docs/providers/aws/r/autoscaling_attachment.html
 */
export function createAutoscalingAttachment(tfgen: TF.Generator, rname: string, params: AutoscalingAttachmentParams): AutoscalingAttachment {
  const fields = fieldsFromAutoscalingAttachmentParams(params);
  const resource = tfgen.createTypedResource('AutoscalingAttachment', 'aws_autoscaling_attachment', rname, fields);

  return {
    ...resource,
  };
}

export interface AutoscalingAttachment extends TF.ResourceT<'AutoscalingAttachment'> {
}

type AutoscalingAttachmentId = {type:'AutoscalingAttachmentId',value:string};

/**
 *  Provides aws_autoscaling_group
 *
 *  see https://www.terraform.io/docs/providers/aws/r/autoscaling_group.html
 */
export function createAutoscalingGroup(tfgen: TF.Generator, rname: string, params: AutoscalingGroupParams): AutoscalingGroup {
  const fields = fieldsFromAutoscalingGroupParams(params);
  const resource = tfgen.createTypedResource('AutoscalingGroup', 'aws_autoscaling_group', rname, fields);
  const id: AutoscalingGroupId =  {type: 'AutoscalingGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: AutoscalingGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'AutoscalingGroup');

  return {
    ...resource,
    id,
    name,
    arn,
  };
}

export interface AutoscalingGroup extends TF.ResourceT<'AutoscalingGroup'> {
  id: AutoscalingGroupId;
  name: string;
  arn: AutoscalingGroupArn;
}

type AutoscalingGroupId = {type:'AutoscalingGroupId',value:string};
export type AutoscalingGroupArn = AT.ArnT<"AutoscalingGroup">;

/**
 *  Provides an EC2 instance resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/instance.html
 */
export function createInstance(tfgen: TF.Generator, rname: string, params: InstanceParams): Instance {
  const fields = fieldsFromInstanceParams(params);
  const resource = tfgen.createTypedResource('Instance', 'aws_instance', rname, fields);
  const id: InstanceId =  {type: 'InstanceId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};
  const availability_zone: AT.AvailabilityZone =  {type: 'AvailabilityZone', value: '${' + TF.resourceName(resource) + '.availability_zone}'};

  return {
    ...resource,
    id,
    arn,
    availability_zone,
  };
}

export interface Instance extends TF.ResourceT<'Instance'> {
  id: InstanceId;
  arn: AT.Arn;
  availability_zone: AT.AvailabilityZone;
}

type InstanceId = {type:'InstanceId',value:string};

/**
 *  Provides an RDS instance resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/db_instance.html
 */
export function createDbInstance(tfgen: TF.Generator, rname: string, params: DbInstanceParams): DbInstance {
  const fields = fieldsFromDbInstanceParams(params);
  const resource = tfgen.createTypedResource('DbInstance', 'aws_db_instance', rname, fields);
  const id: DbInstanceId =  {type: 'DbInstanceId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const username: string =  '${' + TF.resourceName(resource) + '.username}';
  const address: string =  '${' + TF.resourceName(resource) + '.address}';
  const port: string =  '${' + TF.resourceName(resource) + '.port}';
  const arn: DbInstanceArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'DbInstance');

  return {
    ...resource,
    id,
    name,
    username,
    address,
    port,
    arn,
  };
}

export interface DbInstance extends TF.ResourceT<'DbInstance'> {
  id: DbInstanceId;
  name: string;
  username: string;
  address: string;
  port: string;
  arn: DbInstanceArn;
}

type DbInstanceId = {type:'DbInstanceId',value:string};
export type DbInstanceArn = AT.ArnT<"DbInstance">;

/**
 *  Provides an Elastic IP Address.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/eip.html
 */
export function createEip(tfgen: TF.Generator, rname: string, params: EipParams): Eip {
  const fields = fieldsFromEipParams(params);
  const resource = tfgen.createTypedResource('Eip', 'aws_eip', rname, fields);
  const id: EipId =  {type: 'EipId', value: '${' + TF.resourceName(resource) + '.id}'};
  const public_ip: AT.IpAddress =  {type: 'IpAddress', value: '${' + TF.resourceName(resource) + '.public_ip}'};
  const private_ip: AT.IpAddress =  {type: 'IpAddress', value: '${' + TF.resourceName(resource) + '.private_ip}'};

  return {
    ...resource,
    id,
    public_ip,
    private_ip,
  };
}

export interface Eip extends TF.ResourceT<'Eip'> {
  id: EipId;
  public_ip: AT.IpAddress;
  private_ip: AT.IpAddress;
}

type EipId = {type:'EipId',value:string};

/**
 *  Provides a VPC.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/vpc.html
 */
export function createVpc(tfgen: TF.Generator, rname: string, params: VpcParams): Vpc {
  const fields = fieldsFromVpcParams(params);
  const resource = tfgen.createTypedResource('Vpc', 'aws_vpc', rname, fields);
  const id: VpcId =  {type: 'VpcId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface Vpc extends TF.ResourceT<'Vpc'> {
  id: VpcId;
}

type VpcId = {type:'VpcId',value:string};

/**
 *  Provides a VPC Subnet.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/subnet.html
 */
export function createSubnet(tfgen: TF.Generator, rname: string, params: SubnetParams): Subnet {
  const fields = fieldsFromSubnetParams(params);
  const resource = tfgen.createTypedResource('Subnet', 'aws_subnet', rname, fields);
  const id: SubnetId =  {type: 'SubnetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface Subnet extends TF.ResourceT<'Subnet'> {
  id: SubnetId;
}

type SubnetId = {type:'SubnetId',value:string};

/**
 *  Provides a security group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/security_group.html
 */
export function createSecurityGroup(tfgen: TF.Generator, rname: string, params: SecurityGroupParams): SecurityGroup {
  const fields = fieldsFromSecurityGroupParams(params);
  const resource = tfgen.createTypedResource('SecurityGroup', 'aws_security_group', rname, fields);
  const id: SecurityGroupId =  {type: 'SecurityGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const owner_id: string =  '${' + TF.resourceName(resource) + '.owner_id}';

  return {
    ...resource,
    id,
    owner_id,
  };
}

export interface SecurityGroup extends TF.ResourceT<'SecurityGroup'> {
  id: SecurityGroupId;
  owner_id: string;
}

type SecurityGroupId = {type:'SecurityGroupId',value:string};

/**
 *  Provides a resource to create a VPC Internet Gateway.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/internet_gateway.html
 */
export function createInternetGateway(tfgen: TF.Generator, rname: string, params: InternetGatewayParams): InternetGateway {
  const fields = fieldsFromInternetGatewayParams(params);
  const resource = tfgen.createTypedResource('InternetGateway', 'aws_internet_gateway', rname, fields);
  const id: InternetGatewayId =  {type: 'InternetGatewayId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface InternetGateway extends TF.ResourceT<'InternetGateway'> {
  id: InternetGatewayId;
}

type InternetGatewayId = {type:'InternetGatewayId',value:string};

/**
 *  Provides a resource to create a VPC NAT Gateway.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/nat_gateway.html
 */
export function createNatGateway(tfgen: TF.Generator, rname: string, params: NatGatewayParams): NatGateway {
  const fields = fieldsFromNatGatewayParams(params);
  const resource = tfgen.createTypedResource('NatGateway', 'aws_nat_gateway', rname, fields);
  const id: NatGatewayId =  {type: 'NatGatewayId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface NatGateway extends TF.ResourceT<'NatGateway'> {
  id: NatGatewayId;
}

type NatGatewayId = {type:'NatGatewayId',value:string};

/**
 *  Provides a resource to create a VPC routing table.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route_table.html
 */
export function createRouteTable(tfgen: TF.Generator, rname: string, params: RouteTableParams): RouteTable {
  const fields = fieldsFromRouteTableParams(params);
  const resource = tfgen.createTypedResource('RouteTable', 'aws_route_table', rname, fields);
  const id: RouteTableId =  {type: 'RouteTableId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface RouteTable extends TF.ResourceT<'RouteTable'> {
  id: RouteTableId;
}

type RouteTableId = {type:'RouteTableId',value:string};

/**
 *  Provides a resource to create a routing table entry (a route) in a VPC routing table.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route.html
 */
export function createRoute(tfgen: TF.Generator, rname: string, params: RouteParams): Route {
  const fields = fieldsFromRouteParams(params);
  const resource = tfgen.createTypedResource('Route', 'aws_route', rname, fields);

  return {
    ...resource,
  };
}

export interface Route extends TF.ResourceT<'Route'> {
}

type RouteId = {type:'RouteId',value:string};

/**
 *  Provides a resource to create an association between a subnet and routing table.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route_table_association.html
 */
export function createRouteTableAssociation(tfgen: TF.Generator, rname: string, params: RouteTableAssociationParams): RouteTableAssociation {
  const fields = fieldsFromRouteTableAssociationParams(params);
  const resource = tfgen.createTypedResource('RouteTableAssociation', 'aws_route_table_association', rname, fields);
  const id: RouteTableAssociationId =  {type: 'RouteTableAssociationId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface RouteTableAssociation extends TF.ResourceT<'RouteTableAssociation'> {
  id: RouteTableAssociationId;
}

type RouteTableAssociationId = {type:'RouteTableAssociationId',value:string};

/**
 *  Provides a Route53 Hosted Zone resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route53_zone.html
 */
export function createRoute53Zone(tfgen: TF.Generator, rname: string, params: Route53ZoneParams): Route53Zone {
  const fields = fieldsFromRoute53ZoneParams(params);
  const resource = tfgen.createTypedResource('Route53Zone', 'aws_route53_zone', rname, fields);
  const zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.zone_id}'};

  return {
    ...resource,
    zone_id,
  };
}

export interface Route53Zone extends TF.ResourceT<'Route53Zone'> {
  zone_id: AT.HostedZoneId;
}

type Route53ZoneId = {type:'Route53ZoneId',value:string};

/**
 *  Provides a Route53 record resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route53_record.htm
 */
export function createRoute53Record(tfgen: TF.Generator, rname: string, params: Route53RecordParams): Route53Record {
  const fields = fieldsFromRoute53RecordParams(params);
  const resource = tfgen.createTypedResource('Route53Record', 'aws_route53_record', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const fqdn: string =  '${' + TF.resourceName(resource) + '.fqdn}';

  return {
    ...resource,
    name,
    fqdn,
  };
}

export interface Route53Record extends TF.ResourceT<'Route53Record'> {
  name: string;
  fqdn: string;
}

type Route53RecordId = {type:'Route53RecordId',value:string};

/**
 *  Provides a S3 bucket resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/s3_bucket.html
 */
export function createS3Bucket(tfgen: TF.Generator, rname: string, params: S3BucketParams): S3Bucket {
  const fields = fieldsFromS3BucketParams(params);
  const resource = tfgen.createTypedResource('S3Bucket', 'aws_s3_bucket', rname, fields);
  const id: string =  '${' + TF.resourceName(resource) + '.id}';
  const arn: S3BucketArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'S3Bucket');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface S3Bucket extends TF.ResourceT<'S3Bucket'> {
  id: string;
  arn: S3BucketArn;
}

type S3BucketId = {type:'S3BucketId',value:string};
export type S3BucketArn = AT.ArnT<"S3Bucket">;

/**
 *  Provides a S3 bucket object resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/s3_bucket_object.html
 */
export function createS3BucketObject(tfgen: TF.Generator, rname: string, params: S3BucketObjectParams): S3BucketObject {
  const fields = fieldsFromS3BucketObjectParams(params);
  const resource = tfgen.createTypedResource('S3BucketObject', 'aws_s3_bucket_object', rname, fields);
  const id: string =  '${' + TF.resourceName(resource) + '.id}';
  const etag: string =  '${' + TF.resourceName(resource) + '.etag}';
  const version_id: string =  '${' + TF.resourceName(resource) + '.version_id}';

  return {
    ...resource,
    id,
    etag,
    version_id,
  };
}

export interface S3BucketObject extends TF.ResourceT<'S3BucketObject'> {
  id: string;
  etag: string;
  version_id: string;
}

type S3BucketObjectId = {type:'S3BucketObjectId',value:string};

/**
 *  Provides an SNS topic resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/sns_topic.html
 */
export function createSnsTopic(tfgen: TF.Generator, rname: string, params: SnsTopicParams): SnsTopic {
  const fields = fieldsFromSnsTopicParams(params);
  const resource = tfgen.createTypedResource('SnsTopic', 'aws_sns_topic', rname, fields);
  const id: SnsTopicId =  {type: 'SnsTopicId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: SnsTopicArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SnsTopic');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface SnsTopic extends TF.ResourceT<'SnsTopic'> {
  id: SnsTopicId;
  arn: SnsTopicArn;
}

type SnsTopicId = {type:'SnsTopicId',value:string};
export type SnsTopicArn = AT.ArnT<"SnsTopic">;

/**
 *  Provides an IAM user.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_user.html
 */
export function createIamUser(tfgen: TF.Generator, rname: string, params: IamUserParams): IamUser {
  const fields = fieldsFromIamUserParams(params);
  const resource = tfgen.createTypedResource('IamUser', 'aws_iam_user', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const arn: IamUserArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamUser');

  return {
    ...resource,
    name,
    unique_id,
    arn,
  };
}

export interface IamUser extends TF.ResourceT<'IamUser'> {
  name: string;
  unique_id: string;
  arn: IamUserArn;
}

type IamUserId = {type:'IamUserId',value:string};
export type IamUserArn = AT.ArnT<"IamUser">;

/**
 *  Provides an IAM policy attached to a user.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_user_policy.html
 */
export function createIamUserPolicy(tfgen: TF.Generator, rname: string, params: IamUserPolicyParams): IamUserPolicy {
  const fields = fieldsFromIamUserPolicyParams(params);
  const resource = tfgen.createTypedResource('IamUserPolicy', 'aws_iam_user_policy', rname, fields);

  return {
    ...resource,
  };
}

export interface IamUserPolicy extends TF.ResourceT<'IamUserPolicy'> {
}

type IamUserPolicyId = {type:'IamUserPolicyId',value:string};

/**
 *  Attaches a Managed IAM Policy to an IAM user
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_user_policy_attachment.html
 */
export function createIamUserPolicyAttachment(tfgen: TF.Generator, rname: string, params: IamUserPolicyAttachmentParams): IamUserPolicyAttachment {
  const fields = fieldsFromIamUserPolicyAttachmentParams(params);
  const resource = tfgen.createTypedResource('IamUserPolicyAttachment', 'aws_iam_user_policy_attachment', rname, fields);

  return {
    ...resource,
  };
}

export interface IamUserPolicyAttachment extends TF.ResourceT<'IamUserPolicyAttachment'> {
}

type IamUserPolicyAttachmentId = {type:'IamUserPolicyAttachmentId',value:string};

/**
 *  Provides an EC2 Container Registry Repository
 *
 *  see https://www.terraform.io/docs/providers/aws/r/ecr_repository.html
 */
export function createEcrRepository(tfgen: TF.Generator, rname: string, params: EcrRepositoryParams): EcrRepository {
  const fields = fieldsFromEcrRepositoryParams(params);
  const resource = tfgen.createTypedResource('EcrRepository', 'aws_ecr_repository', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const registry_id: string =  '${' + TF.resourceName(resource) + '.registry_id}';
  const repository_url: string =  '${' + TF.resourceName(resource) + '.repository_url}';
  const arn: EcrRepositoryArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'EcrRepository');

  return {
    ...resource,
    name,
    registry_id,
    repository_url,
    arn,
  };
}

export interface EcrRepository extends TF.ResourceT<'EcrRepository'> {
  name: string;
  registry_id: string;
  repository_url: string;
  arn: EcrRepositoryArn;
}

type EcrRepositoryId = {type:'EcrRepositoryId',value:string};
export type EcrRepositoryArn = AT.ArnT<"EcrRepository">;

/**
 *  Provides an RDS DB subnet group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/db_subnet_group.html
 */
export function createDbSubnetGroup(tfgen: TF.Generator, rname: string, params: DbSubnetGroupParams): DbSubnetGroup {
  const fields = fieldsFromDbSubnetGroupParams(params);
  const resource = tfgen.createTypedResource('DbSubnetGroup', 'aws_db_subnet_group', rname, fields);
  const id: DbSubnetGroupId =  {type: 'DbSubnetGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: DbSubnetGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'DbSubnetGroup');

  return {
    ...resource,
    id,
    name,
    arn,
  };
}

export interface DbSubnetGroup extends TF.ResourceT<'DbSubnetGroup'> {
  id: DbSubnetGroupId;
  name: string;
  arn: DbSubnetGroupArn;
}

type DbSubnetGroupId = {type:'DbSubnetGroupId',value:string};
export type DbSubnetGroupArn = AT.ArnT<"DbSubnetGroup">;

/**
 *  Provides a CloudWatch Metric Alarm resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_metric_alarm.html
 */
export function createCloudwatchMetricAlarm(tfgen: TF.Generator, rname: string, params: CloudwatchMetricAlarmParams): CloudwatchMetricAlarm {
  const fields = fieldsFromCloudwatchMetricAlarmParams(params);
  const resource = tfgen.createTypedResource('CloudwatchMetricAlarm', 'aws_cloudwatch_metric_alarm', rname, fields);
  const id: CloudwatchMetricAlarmId =  {type: 'CloudwatchMetricAlarmId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface CloudwatchMetricAlarm extends TF.ResourceT<'CloudwatchMetricAlarm'> {
  id: CloudwatchMetricAlarmId;
}

type CloudwatchMetricAlarmId = {type:'CloudwatchMetricAlarmId',value:string};

/**
 *  Provides an IAM role.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_role.html
 */
export function createIamRole(tfgen: TF.Generator, rname: string, params: IamRoleParams): IamRole {
  const fields = fieldsFromIamRoleParams(params);
  const resource = tfgen.createTypedResource('IamRole', 'aws_iam_role', rname, fields);
  const id: IamRoleId =  {type: 'IamRoleId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const create_date: string =  '${' + TF.resourceName(resource) + '.create_date}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const description: string =  '${' + TF.resourceName(resource) + '.description}';
  const arn: IamRoleArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamRole');

  return {
    ...resource,
    id,
    name,
    create_date,
    unique_id,
    description,
    arn,
  };
}

export interface IamRole extends TF.ResourceT<'IamRole'> {
  id: IamRoleId;
  name: string;
  create_date: string;
  unique_id: string;
  description: string;
  arn: IamRoleArn;
}

type IamRoleId = {type:'IamRoleId',value:string};
export type IamRoleArn = AT.ArnT<"IamRole">;

/**
 *  Provides an IAM role policy
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_role_policy.html
 */
export function createIamRolePolicy(tfgen: TF.Generator, rname: string, params: IamRolePolicyParams): IamRolePolicy {
  const fields = fieldsFromIamRolePolicyParams(params);
  const resource = tfgen.createTypedResource('IamRolePolicy', 'aws_iam_role_policy', rname, fields);
  const id: string =  '${' + TF.resourceName(resource) + '.id}';
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const policy: string =  '${' + TF.resourceName(resource) + '.policy}';
  const role: string =  '${' + TF.resourceName(resource) + '.role}';

  return {
    ...resource,
    id,
    name,
    policy,
    role,
  };
}

export interface IamRolePolicy extends TF.ResourceT<'IamRolePolicy'> {
  id: string;
  name: string;
  policy: string;
  role: string;
}

type IamRolePolicyId = {type:'IamRolePolicyId',value:string};

/**
 *  Provides an IAM instance profile.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_instance_profile.html
 */
export function createIamInstanceProfile(tfgen: TF.Generator, rname: string, params: IamInstanceProfileParams): IamInstanceProfile {
  const fields = fieldsFromIamInstanceProfileParams(params);
  const resource = tfgen.createTypedResource('IamInstanceProfile', 'aws_iam_instance_profile', rname, fields);
  const id: IamInstanceProfileId =  {type: 'IamInstanceProfileId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const create_date: string =  '${' + TF.resourceName(resource) + '.create_date}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const arn: IamInstanceProfileArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamInstanceProfile');

  return {
    ...resource,
    id,
    name,
    create_date,
    unique_id,
    arn,
  };
}

export interface IamInstanceProfile extends TF.ResourceT<'IamInstanceProfile'> {
  id: IamInstanceProfileId;
  name: string;
  create_date: string;
  unique_id: string;
  arn: IamInstanceProfileArn;
}

type IamInstanceProfileId = {type:'IamInstanceProfileId',value:string};
export type IamInstanceProfileArn = AT.ArnT<"IamInstanceProfile">;

/**
 *  Provides an SQS queue.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/sqs_queue.html
 */
export function createSqsQueue(tfgen: TF.Generator, rname: string, params: SqsQueueParams): SqsQueue {
  const fields = fieldsFromSqsQueueParams(params);
  const resource = tfgen.createTypedResource('SqsQueue', 'aws_sqs_queue', rname, fields);
  const id: SqsQueueId =  {type: 'SqsQueueId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: SqsQueueArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SqsQueue');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface SqsQueue extends TF.ResourceT<'SqsQueue'> {
  id: SqsQueueId;
  arn: SqsQueueArn;
}

type SqsQueueId = {type:'SqsQueueId',value:string};
export type SqsQueueArn = AT.ArnT<"SqsQueue">;

/**
 *  Allows you to set a policy of an SQS Queue while referencing ARN of the queue within the policy.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/sqs_queue_policy.html
 */
export function createSqsQueuePolicy(tfgen: TF.Generator, rname: string, params: SqsQueuePolicyParams): SqsQueuePolicy {
  const fields = fieldsFromSqsQueuePolicyParams(params);
  const resource = tfgen.createTypedResource('SqsQueuePolicy', 'aws_sqs_queue_policy', rname, fields);

  return {
    ...resource,
  };
}

export interface SqsQueuePolicy extends TF.ResourceT<'SqsQueuePolicy'> {
}

type SqsQueuePolicyId = {type:'SqsQueuePolicyId',value:string};

/**
 *  Provides a Load Balancer resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb.html
 */
export function createLb(tfgen: TF.Generator, rname: string, params: LbParams): Lb {
  const fields = fieldsFromLbParams(params);
  const resource = tfgen.createTypedResource('Lb', 'aws_lb', rname, fields);
  const id: LbId =  {type: 'LbId', value: '${' + TF.resourceName(resource) + '.id}'};
  const dns_name: string =  '${' + TF.resourceName(resource) + '.dns_name}';
  const zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.zone_id}'};
  const arn: LbArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'Lb');

  return {
    ...resource,
    id,
    dns_name,
    zone_id,
    arn,
  };
}

export interface Lb extends TF.ResourceT<'Lb'> {
  id: LbId;
  dns_name: string;
  zone_id: AT.HostedZoneId;
  arn: LbArn;
}

type LbId = {type:'LbId',value:string};
export type LbArn = AT.ArnT<"Lb">;

/**
 *  Provides a Load Balancer Listener resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_listener.html
 */
export function createLbListener(tfgen: TF.Generator, rname: string, params: LbListenerParams): LbListener {
  const fields = fieldsFromLbListenerParams(params);
  const resource = tfgen.createTypedResource('LbListener', 'aws_lb_listener', rname, fields);
  const id: LbListenerId =  {type: 'LbListenerId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: LbListenerArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LbListener');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface LbListener extends TF.ResourceT<'LbListener'> {
  id: LbListenerId;
  arn: LbListenerArn;
}

type LbListenerId = {type:'LbListenerId',value:string};
export type LbListenerArn = AT.ArnT<"LbListener">;

/**
 *  The ACM certificate resource allows requesting and management of certificates from the Amazon Certificate Manager.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/acm_certificate.html
 */
export function createAcmCertificate(tfgen: TF.Generator, rname: string, params: AcmCertificateParams): AcmCertificate {
  const fields = fieldsFromAcmCertificateParams(params);
  const resource = tfgen.createTypedResource('AcmCertificate', 'aws_acm_certificate', rname, fields);
  const id: AcmCertificateId =  {type: 'AcmCertificateId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: AcmCertificateArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'AcmCertificate');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface AcmCertificate extends TF.ResourceT<'AcmCertificate'> {
  id: AcmCertificateId;
  arn: AcmCertificateArn;
}

type AcmCertificateId = {type:'AcmCertificateId',value:string};
export type AcmCertificateArn = AT.ArnT<"AcmCertificate">;

/**
 *  This resource represents a successful validation of an ACM certificate in concert with other resources.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/acm_certificate.html
 */
export function createAcmCertificateValidation(tfgen: TF.Generator, rname: string, params: AcmCertificateValidationParams): AcmCertificateValidation {
  const fields = fieldsFromAcmCertificateValidationParams(params);
  const resource = tfgen.createTypedResource('AcmCertificateValidation', 'aws_acm_certificate_validation', rname, fields);

  return {
    ...resource,
  };
}

export interface AcmCertificateValidation extends TF.ResourceT<'AcmCertificateValidation'> {
}

type AcmCertificateValidationId = {type:'AcmCertificateValidationId',value:string};

/**
 *  Provides a Load Balancer Listener Certificate resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_listener_certificate.html
 */
export function createLbListenerCertificate(tfgen: TF.Generator, rname: string, params: LbListenerCertificateParams): LbListenerCertificate {
  const fields = fieldsFromLbListenerCertificateParams(params);
  const resource = tfgen.createTypedResource('LbListenerCertificate', 'aws_lb_listener_certificate', rname, fields);
  const id: LbListenerCertificateId =  {type: 'LbListenerCertificateId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: LbListenerCertificateArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LbListenerCertificate');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface LbListenerCertificate extends TF.ResourceT<'LbListenerCertificate'> {
  id: LbListenerCertificateId;
  arn: LbListenerCertificateArn;
}

type LbListenerCertificateId = {type:'LbListenerCertificateId',value:string};
export type LbListenerCertificateArn = AT.ArnT<"LbListenerCertificate">;

/**
 *  Provides a Target Group resource for use with Load Balancer resources.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_target_group.html
 */
export function createLbTargetGroup(tfgen: TF.Generator, rname: string, params: LbTargetGroupParams): LbTargetGroup {
  const fields = fieldsFromLbTargetGroupParams(params);
  const resource = tfgen.createTypedResource('LbTargetGroup', 'aws_lb_target_group', rname, fields);
  const id: LbTargetGroupId =  {type: 'LbTargetGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn_suffix: string =  '${' + TF.resourceName(resource) + '.arn_suffix}';
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: LbTargetGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LbTargetGroup');

  return {
    ...resource,
    id,
    arn_suffix,
    name,
    arn,
  };
}

export interface LbTargetGroup extends TF.ResourceT<'LbTargetGroup'> {
  id: LbTargetGroupId;
  arn_suffix: string;
  name: string;
  arn: LbTargetGroupArn;
}

type LbTargetGroupId = {type:'LbTargetGroupId',value:string};
export type LbTargetGroupArn = AT.ArnT<"LbTargetGroup">;

/**
 *  Provides the ability to register instances and containers with an Application Load Balancer (ALB) or Network Load Balancer (NLB) target group. 
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_target_group_attachment.html
 */
export function createLbTargetGroupAttachment(tfgen: TF.Generator, rname: string, params: LbTargetGroupAttachmentParams): LbTargetGroupAttachment {
  const fields = fieldsFromLbTargetGroupAttachmentParams(params);
  const resource = tfgen.createTypedResource('LbTargetGroupAttachment', 'aws_lb_target_group_attachment', rname, fields);
  const id: LbTargetGroupAttachmentId =  {type: 'LbTargetGroupAttachmentId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface LbTargetGroupAttachment extends TF.ResourceT<'LbTargetGroupAttachment'> {
  id: LbTargetGroupAttachmentId;
}

type LbTargetGroupAttachmentId = {type:'LbTargetGroupAttachmentId',value:string};

/**
 *  Provides a Load Balancer Listener Rule resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_listener_rule.html
 */
export function createLbListenerRule(tfgen: TF.Generator, rname: string, params: LbListenerRuleParams): LbListenerRule {
  const fields = fieldsFromLbListenerRuleParams(params);
  const resource = tfgen.createTypedResource('LbListenerRule', 'aws_lb_listener_rule', rname, fields);
  const id: LbListenerRuleId =  {type: 'LbListenerRuleId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};

  return {
    ...resource,
    id,
    arn,
  };
}

export interface LbListenerRule extends TF.ResourceT<'LbListenerRule'> {
  id: LbListenerRuleId;
  arn: AT.Arn;
}

type LbListenerRuleId = {type:'LbListenerRuleId',value:string};

/**
 *  Provides an elasticsearch cluster
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticsearch_domain.html
 */
export function createElasticsearchDomain(tfgen: TF.Generator, rname: string, params: ElasticsearchDomainParams): ElasticsearchDomain {
  const fields = fieldsFromElasticsearchDomainParams(params);
  const resource = tfgen.createTypedResource('ElasticsearchDomain', 'aws_elasticsearch_domain', rname, fields);
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};
  const domain_id: string =  '${' + TF.resourceName(resource) + '.domain_id}';
  const domain_name: string =  '${' + TF.resourceName(resource) + '.domain_name}';
  const endpoint: string =  '${' + TF.resourceName(resource) + '.endpoint}';

  return {
    ...resource,
    arn,
    domain_id,
    domain_name,
    endpoint,
  };
}

export interface ElasticsearchDomain extends TF.ResourceT<'ElasticsearchDomain'> {
  arn: AT.Arn;
  domain_id: string;
  domain_name: string;
  endpoint: string;
}

type ElasticsearchDomainId = {type:'ElasticsearchDomainId',value:string};

/**
 *  Allows setting policy to an Elasticsearch domain while referencing domain attributes (e.g. ARN)
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticsearch_domain_policy.html
 */
export function createElasticsearchDomainPolicy(tfgen: TF.Generator, rname: string, params: ElasticsearchDomainPolicyParams): ElasticsearchDomainPolicy {
  const fields = fieldsFromElasticsearchDomainPolicyParams(params);
  const resource = tfgen.createTypedResource('ElasticsearchDomainPolicy', 'aws_elasticsearch_domain_policy', rname, fields);
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};

  return {
    ...resource,
    arn,
  };
}

export interface ElasticsearchDomainPolicy extends TF.ResourceT<'ElasticsearchDomainPolicy'> {
  arn: AT.Arn;
}

type ElasticsearchDomainPolicyId = {type:'ElasticsearchDomainPolicyId',value:string};

/**
 *  Provides a CloudWatch Log Group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_log_group.html
 */
export function createCloudwatchLogGroup(tfgen: TF.Generator, rname: string, params: CloudwatchLogGroupParams): CloudwatchLogGroup {
  const fields = fieldsFromCloudwatchLogGroupParams(params);
  const resource = tfgen.createTypedResource('CloudwatchLogGroup', 'aws_cloudwatch_log_group', rname, fields);
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};

  return {
    ...resource,
    arn,
  };
}

export interface CloudwatchLogGroup extends TF.ResourceT<'CloudwatchLogGroup'> {
  arn: AT.Arn;
}

type CloudwatchLogGroupId = {type:'CloudwatchLogGroupId',value:string};

/**
 *  Provides aws_launch_configuration
 *
 *  see https://www.terraform.io/docs/providers/aws/r/launch_configuration.html
 */
export function createLaunchConfiguration(tfgen: TF.Generator, rname: string, params: LaunchConfigurationParams): LaunchConfiguration {
  const fields = fieldsFromLaunchConfigurationParams(params);
  const resource = tfgen.createTypedResource('LaunchConfiguration', 'aws_launch_configuration', rname, fields);
  const id: LaunchConfigurationId =  {type: 'LaunchConfigurationId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';

  return {
    ...resource,
    id,
    name,
  };
}

export interface LaunchConfiguration extends TF.ResourceT<'LaunchConfiguration'> {
  id: LaunchConfigurationId;
  name: string;
}

type LaunchConfigurationId = {type:'LaunchConfigurationId',value:string};

/**
 *  Provides a Kinesis Firehose Delivery Stream resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/kinesis_firehose_delivery_stream.html
 */
export function createKinesisFirehoseDeliveryStream(tfgen: TF.Generator, rname: string, params: KinesisFirehoseDeliveryStreamParams): KinesisFirehoseDeliveryStream {
  const fields = fieldsFromKinesisFirehoseDeliveryStreamParams(params);
  const resource = tfgen.createTypedResource('KinesisFirehoseDeliveryStream', 'aws_kinesis_firehose_delivery_stream', rname, fields);
  const arn: KinesisFirehoseDeliveryStreamArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'KinesisFirehoseDeliveryStream');

  return {
    ...resource,
    arn,
  };
}

export interface KinesisFirehoseDeliveryStream extends TF.ResourceT<'KinesisFirehoseDeliveryStream'> {
  arn: KinesisFirehoseDeliveryStreamArn;
}

type KinesisFirehoseDeliveryStreamId = {type:'KinesisFirehoseDeliveryStreamId',value:string};
export type KinesisFirehoseDeliveryStreamArn = AT.ArnT<"KinesisFirehoseDeliveryStream">;

/**
 *  Provides a S3 bucket metrics configuration resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/s3_bucket_metric.html
 */
export function createS3BucketMetric(tfgen: TF.Generator, rname: string, params: S3BucketMetricParams): S3BucketMetric {
  const fields = fieldsFromS3BucketMetricParams(params);
  const resource = tfgen.createTypedResource('S3BucketMetric', 'aws_s3_bucket_metric', rname, fields);

  return {
    ...resource,
  };
}

export interface S3BucketMetric extends TF.ResourceT<'S3BucketMetric'> {
}

type S3BucketMetricId = {type:'S3BucketMetricId',value:string};

/**
 *  Provides an ElastiCache parameter group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticache_parameter_group.html
 */
export function createElasticacheParameterGroup(tfgen: TF.Generator, rname: string, params: ElasticacheParameterGroupParams): ElasticacheParameterGroup {
  const fields = fieldsFromElasticacheParameterGroupParams(params);
  const resource = tfgen.createTypedResource('ElasticacheParameterGroup', 'aws_elasticache_parameter_group', rname, fields);
  const name: AT.ElasticacheParameterGroupName =  {type: 'ElasticacheParameterGroupName', value: '${' + TF.resourceName(resource) + '.name}'};
  const family: AT.ElasticacheParameterGroupFamily =  {type: 'ElasticacheParameterGroupFamily', value: '${' + TF.resourceName(resource) + '.family}'};
  const description: string =  '${' + TF.resourceName(resource) + '.description}';
  const arn: ElasticacheParameterGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'ElasticacheParameterGroup');

  return {
    ...resource,
    name,
    family,
    description,
    arn,
  };
}

export interface ElasticacheParameterGroup extends TF.ResourceT<'ElasticacheParameterGroup'> {
  name: AT.ElasticacheParameterGroupName;
  family: AT.ElasticacheParameterGroupFamily;
  description: string;
  arn: ElasticacheParameterGroupArn;
}

type ElasticacheParameterGroupId = {type:'ElasticacheParameterGroupId',value:string};
export type ElasticacheParameterGroupArn = AT.ArnT<"ElasticacheParameterGroup">;

/**
 *  Provides an elasticache cluster resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticache_cluster.html
 */
export function createElasticacheCluster(tfgen: TF.Generator, rname: string, params: ElasticacheClusterParams): ElasticacheCluster {
  const fields = fieldsFromElasticacheClusterParams(params);
  const resource = tfgen.createTypedResource('ElasticacheCluster', 'aws_elasticache_cluster', rname, fields);
  const cluster_id: string =  '${' + TF.resourceName(resource) + '.cluster_id}';
  const engine: string =  '${' + TF.resourceName(resource) + '.engine}';
  const node_type: string =  '${' + TF.resourceName(resource) + '.node_type}';
  const parameter_group_name: AT.ElasticacheParameterGroupName =  {type: 'ElasticacheParameterGroupName', value: '${' + TF.resourceName(resource) + '.parameter_group_name}'};
  const arn: ElasticacheClusterArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'ElasticacheCluster');

  return {
    ...resource,
    cluster_id,
    engine,
    node_type,
    parameter_group_name,
    arn,
  };
}

export interface ElasticacheCluster extends TF.ResourceT<'ElasticacheCluster'> {
  cluster_id: string;
  engine: string;
  node_type: string;
  parameter_group_name: AT.ElasticacheParameterGroupName;
  arn: ElasticacheClusterArn;
}

type ElasticacheClusterId = {type:'ElasticacheClusterId',value:string};
export type ElasticacheClusterArn = AT.ArnT<"ElasticacheCluster">;

/**
 *  Provides a WAF Byte Match Set Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/waf_byte_match_set.html
 */
export function createWafByteMatchSet(tfgen: TF.Generator, rname: string, params: WafByteMatchSetParams): WafByteMatchSet {
  const fields = fieldsFromWafByteMatchSetParams(params);
  const resource = tfgen.createTypedResource('WafByteMatchSet', 'aws_waf_byte_match_set', rname, fields);
  const id: WafByteMatchSetId =  {type: 'WafByteMatchSetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafByteMatchSet extends TF.ResourceT<'WafByteMatchSet'> {
  id: WafByteMatchSetId;
}

type WafByteMatchSetId = {type:'WafByteMatchSetId',value:string};

/**
 *  Provides a WAF IPSet Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/waf_ipset.html
 */
export function createWafIpset(tfgen: TF.Generator, rname: string, params: WafIpsetParams): WafIpset {
  const fields = fieldsFromWafIpsetParams(params);
  const resource = tfgen.createTypedResource('WafIpset', 'aws_waf_ipset', rname, fields);
  const id: WafIpsetId =  {type: 'WafIpsetId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: WafIpsetArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'WafIpset');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface WafIpset extends TF.ResourceT<'WafIpset'> {
  id: WafIpsetId;
  arn: WafIpsetArn;
}

type WafIpsetId = {type:'WafIpsetId',value:string};
export type WafIpsetArn = AT.ArnT<"WafIpset">;

/**
 *  Provides a WAF Regional Regex Match Set Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_regex_match_set.html
 */
export function createWafregionalRegexMatchSet(tfgen: TF.Generator, rname: string, params: WafregionalRegexMatchSetParams): WafregionalRegexMatchSet {
  const fields = fieldsFromWafregionalRegexMatchSetParams(params);
  const resource = tfgen.createTypedResource('WafregionalRegexMatchSet', 'aws_wafregional_regex_match_set', rname, fields);
  const id: WafregionalRegexMatchSetId =  {type: 'WafregionalRegexMatchSetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalRegexMatchSet extends TF.ResourceT<'WafregionalRegexMatchSet'> {
  id: WafregionalRegexMatchSetId;
}

type WafregionalRegexMatchSetId = {type:'WafregionalRegexMatchSetId',value:string};

/**
 *  Provides a WAF Regional Regex Pattern Set Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_regex_pattern_set.html
 */
export function createWafregionalRegexPatternSet(tfgen: TF.Generator, rname: string, params: WafregionalRegexPatternSetParams): WafregionalRegexPatternSet {
  const fields = fieldsFromWafregionalRegexPatternSetParams(params);
  const resource = tfgen.createTypedResource('WafregionalRegexPatternSet', 'aws_wafregional_regex_pattern_set', rname, fields);
  const id: WafregionalRegexPatternSetId =  {type: 'WafregionalRegexPatternSetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalRegexPatternSet extends TF.ResourceT<'WafregionalRegexPatternSet'> {
  id: WafregionalRegexPatternSetId;
}

type WafregionalRegexPatternSetId = {type:'WafregionalRegexPatternSetId',value:string};

/**
 *  Provides a WAF Regional IPSet Resource for use with Application Load Balancer.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_ipset.html
 */
export function createWafregionalIpset(tfgen: TF.Generator, rname: string, params: WafregionalIpsetParams): WafregionalIpset {
  const fields = fieldsFromWafregionalIpsetParams(params);
  const resource = tfgen.createTypedResource('WafregionalIpset', 'aws_wafregional_ipset', rname, fields);
  const id: WafregionalIpsetId =  {type: 'WafregionalIpsetId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: WafregionalIpsetArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'WafregionalIpset');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface WafregionalIpset extends TF.ResourceT<'WafregionalIpset'> {
  id: WafregionalIpsetId;
  arn: WafregionalIpsetArn;
}

type WafregionalIpsetId = {type:'WafregionalIpsetId',value:string};
export type WafregionalIpsetArn = AT.ArnT<"WafregionalIpset">;

export interface AutoscalingGroupTagParams {
  key: string;
  value: string;
  propagate_at_launch: boolean;
}

export function fieldsFromAutoscalingGroupTagParams(params: AutoscalingGroupTagParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "key", params.key, TF.stringValue);
  TF.addField(fields, "value", params.value, TF.stringValue);
  TF.addField(fields, "propagate_at_launch", params.propagate_at_launch, TF.booleanValue);
  return fields;
}

export interface AutoscalingGroupParams {
  name?: string;
  name_prefix?: string;
  min_size: number;
  max_size: number;
  vpc_zone_identifier?: SubnetId[];
  launch_configuration: string;
  load_balancers?: string[];
  tags?: AutoscalingGroupTagParams[];
}

export function fieldsFromAutoscalingGroupParams(params: AutoscalingGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "min_size", params.min_size, TF.numberValue);
  TF.addField(fields, "max_size", params.max_size, TF.numberValue);
  TF.addOptionalField(fields, "vpc_zone_identifier", params.vpc_zone_identifier, TF.listValue(TF.resourceIdValue));
  TF.addField(fields, "launch_configuration", params.launch_configuration, TF.stringValue);
  TF.addOptionalField(fields, "load_balancers", params.load_balancers, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.listValue((v) => TF.mapValue(fieldsFromAutoscalingGroupTagParams(v))));
  return fields;
}

export interface AutoscalingAttachmentParams {
  autoscaling_group_name: AutoscalingGroupId;
  alb_target_group_arn: AT.ArnT<"LbTargetGroup">;
}

export function fieldsFromAutoscalingAttachmentParams(params: AutoscalingAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "autoscaling_group_name", params.autoscaling_group_name, TF.resourceIdValue);
  TF.addField(fields, "alb_target_group_arn", params.alb_target_group_arn, TF.resourceArnValue);
  return fields;
}

export interface InstanceRootBlockDeviceParams {
  volume_type?: 'standard' | 'gp2' | 'io1';
  volume_size?: number;
  iops?: number;
  delete_on_termination?: boolean;
}

export function fieldsFromInstanceRootBlockDeviceParams(params: InstanceRootBlockDeviceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "volume_type", params.volume_type, TF.stringValue);
  TF.addOptionalField(fields, "volume_size", params.volume_size, TF.numberValue);
  TF.addOptionalField(fields, "iops", params.iops, TF.numberValue);
  TF.addOptionalField(fields, "delete_on_termination", params.delete_on_termination, TF.booleanValue);
  return fields;
}

export interface InstanceParams {
  ami: AT.Ami;
  instance_type: AT.InstanceType;
  availability_zone?: AT.AvailabilityZone;
  ebs_optimised?: boolean;
  key_name?: AT.KeyName;
  monitoring?: boolean;
  subnet_id?: SubnetId;
  associate_public_ip_address?: boolean;
  root_block_device?: InstanceRootBlockDeviceParams;
  user_data?: string;
  iam_instance_profile?: IamInstanceProfileId;
  vpc_security_group_ids?: SecurityGroupId[];
  tags?: TF.TagsMap;
}

export function fieldsFromInstanceParams(params: InstanceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "ami", params.ami, TF.stringAliasValue);
  TF.addField(fields, "instance_type", params.instance_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  TF.addOptionalField(fields, "ebs_optimised", params.ebs_optimised, TF.booleanValue);
  TF.addOptionalField(fields, "key_name", params.key_name, TF.stringAliasValue);
  TF.addOptionalField(fields, "monitoring", params.monitoring, TF.booleanValue);
  TF.addOptionalField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "associate_public_ip_address", params.associate_public_ip_address, TF.booleanValue);
  TF.addOptionalField(fields, "root_block_device", params.root_block_device, (v) => TF.mapValue(fieldsFromInstanceRootBlockDeviceParams(v)));
  TF.addOptionalField(fields, "user_data", params.user_data, TF.stringValue);
  TF.addOptionalField(fields, "iam_instance_profile", params.iam_instance_profile, TF.resourceIdValue);
  TF.addOptionalField(fields, "vpc_security_group_ids", params.vpc_security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface DbInstanceParams {
  allocated_storage: number;
  engine: AT.DbEngine;
  instance_class: AT.DbInstanceType;
  username: string;
  password?: string;
  engine_version?: string;
  identifier?: string;
  name?: string;
  port?: number;
  publicly_accessible?: boolean;
  backup_retention_period?: number;
  vpc_security_group_ids?: SecurityGroupId[];
  parameter_group_name?: string;
  db_subnet_group_name?: string;
  tags?: TF.TagsMap;
  skip_final_snapshot?: boolean;
  final_snapshot_identifier?: string;
  multi_az?: boolean;
  license_model?: string;
  auto_minor_version_upgrade?: boolean;
  replicate_source_db?: DbInstanceId;
  apply_immediately?: boolean;
  storage_type?: AT.DbInstanceStorageType;
}

export function fieldsFromDbInstanceParams(params: DbInstanceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "allocated_storage", params.allocated_storage, TF.numberValue);
  TF.addField(fields, "engine", params.engine, TF.stringAliasValue);
  TF.addField(fields, "instance_class", params.instance_class, TF.stringAliasValue);
  TF.addField(fields, "username", params.username, TF.stringValue);
  TF.addOptionalField(fields, "password", params.password, TF.stringValue);
  TF.addOptionalField(fields, "engine_version", params.engine_version, TF.stringValue);
  TF.addOptionalField(fields, "identifier", params.identifier, TF.stringValue);
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "publicly_accessible", params.publicly_accessible, TF.booleanValue);
  TF.addOptionalField(fields, "backup_retention_period", params.backup_retention_period, TF.numberValue);
  TF.addOptionalField(fields, "vpc_security_group_ids", params.vpc_security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "parameter_group_name", params.parameter_group_name, TF.stringValue);
  TF.addOptionalField(fields, "db_subnet_group_name", params.db_subnet_group_name, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  TF.addOptionalField(fields, "skip_final_snapshot", params.skip_final_snapshot, TF.booleanValue);
  TF.addOptionalField(fields, "final_snapshot_identifier", params.final_snapshot_identifier, TF.stringValue);
  TF.addOptionalField(fields, "multi_az", params.multi_az, TF.booleanValue);
  TF.addOptionalField(fields, "license_model", params.license_model, TF.stringValue);
  TF.addOptionalField(fields, "auto_minor_version_upgrade", params.auto_minor_version_upgrade, TF.booleanValue);
  TF.addOptionalField(fields, "replicate_source_db", params.replicate_source_db, TF.stringAliasValue);
  TF.addOptionalField(fields, "apply_immediately", params.apply_immediately, TF.booleanValue);
  TF.addOptionalField(fields, "storage_type", params.storage_type, TF.stringAliasValue);
  return fields;
}

export interface EipParams {
  vpc?: boolean;
  instance?: InstanceId;
  tags?: TF.TagsMap;
}

export function fieldsFromEipParams(params: EipParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "vpc", params.vpc, TF.booleanValue);
  TF.addOptionalField(fields, "instance", params.instance, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface VpcParams {
  cidr_block: AT.CidrBlock;
  instance_tenancy?: string;
  enable_dns_support?: boolean;
  enable_dns_hostnames?: boolean;
  enable_classic_link?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromVpcParams(params: VpcParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "cidr_block", params.cidr_block, TF.stringAliasValue);
  TF.addOptionalField(fields, "instance_tenancy", params.instance_tenancy, TF.stringValue);
  TF.addOptionalField(fields, "enable_dns_support", params.enable_dns_support, TF.booleanValue);
  TF.addOptionalField(fields, "enable_dns_hostnames", params.enable_dns_hostnames, TF.booleanValue);
  TF.addOptionalField(fields, "enable_classic_link", params.enable_classic_link, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SubnetParams {
  vpc_id: VpcId;
  cidr_block: AT.CidrBlock;
  map_public_ip_on_launch?: boolean;
  availability_zone?: AT.AvailabilityZone;
  tags?: TF.TagsMap;
}

export function fieldsFromSubnetParams(params: SubnetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addField(fields, "cidr_block", params.cidr_block, TF.stringAliasValue);
  TF.addOptionalField(fields, "map_public_ip_on_launch", params.map_public_ip_on_launch, TF.booleanValue);
  TF.addOptionalField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SecurityGroupParams {
  name?: string;
  name_prefix?: string;
  description?: string;
  ingress?: IngressRuleParams[];
  egress?: EgressRuleParams[];
  vpc_id?: VpcId;
  tags?: TF.TagsMap;
}

export function fieldsFromSecurityGroupParams(params: SecurityGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addOptionalField(fields, "ingress", params.ingress, TF.listValue((v) => TF.mapValue(fieldsFromIngressRuleParams(v))));
  TF.addOptionalField(fields, "egress", params.egress, TF.listValue((v) => TF.mapValue(fieldsFromEgressRuleParams(v))));
  TF.addOptionalField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface IngressRuleParams {
  from_port: number;
  to_port: number;
  protocol: 'tcp' | 'udp' | 'icmp' | '-1';
  cidr_blocks: AT.CidrBlock[];
}

export function fieldsFromIngressRuleParams(params: IngressRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "from_port", params.from_port, TF.numberValue);
  TF.addField(fields, "to_port", params.to_port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addField(fields, "cidr_blocks", params.cidr_blocks, TF.listValue(TF.stringAliasValue));
  return fields;
}

export interface EgressRuleParams {
  from_port: number;
  to_port: number;
  protocol: 'tcp' | 'udp' | 'icmp' | '-1';
  cidr_blocks: AT.CidrBlock[];
}

export function fieldsFromEgressRuleParams(params: EgressRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "from_port", params.from_port, TF.numberValue);
  TF.addField(fields, "to_port", params.to_port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addField(fields, "cidr_blocks", params.cidr_blocks, TF.listValue(TF.stringAliasValue));
  return fields;
}

export interface InternetGatewayParams {
  vpc_id: VpcId;
  tags?: TF.TagsMap;
}

export function fieldsFromInternetGatewayParams(params: InternetGatewayParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface NatGatewayParams {
  allocation_id: EipId;
  subnet_id: SubnetId;
}

export function fieldsFromNatGatewayParams(params: NatGatewayParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "allocation_id", params.allocation_id, TF.resourceIdValue);
  TF.addField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  return fields;
}

export interface RouteTableParams {
  vpc_id: VpcId;
  tags?: TF.TagsMap;
}

export function fieldsFromRouteTableParams(params: RouteTableParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface RouteParams {
  route_table_id: RouteTableId;
  destination_cidr_block: AT.CidrBlock;
  nat_gateway_id?: NatGatewayId;
  gateway_id?: InternetGatewayId;
}

export function fieldsFromRouteParams(params: RouteParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "route_table_id", params.route_table_id, TF.resourceIdValue);
  TF.addField(fields, "destination_cidr_block", params.destination_cidr_block, TF.stringAliasValue);
  TF.addOptionalField(fields, "nat_gateway_id", params.nat_gateway_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "gateway_id", params.gateway_id, TF.resourceIdValue);
  return fields;
}

export interface RouteTableAssociationParams {
  subnet_id: SubnetId;
  route_table_id: RouteTableId;
}

export function fieldsFromRouteTableAssociationParams(params: RouteTableAssociationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  TF.addField(fields, "route_table_id", params.route_table_id, TF.resourceIdValue);
  return fields;
}

export interface Route53ZoneParams {
  name: string;
  comment?: string;
  vpc_id?: VpcId;
  vpc_region?: AT.Region;
  force_destroy?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromRoute53ZoneParams(params: Route53ZoneParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "comment", params.comment, TF.stringValue);
  TF.addOptionalField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "vpc_region", params.vpc_region, TF.stringAliasValue);
  TF.addOptionalField(fields, "force_destroy", params.force_destroy, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface Route53RecordParams {
  zone_id: AT.HostedZoneId;
  name: string;
  type: 'A' | 'AAAA' | 'CAA' | 'CNAME' | 'MX' | 'NAPTR' | 'NS' | 'PTR' | 'SOA' | 'SPF' | 'SRV' | 'TXT';
  ttl?: string;
  records?: string[];
  alias?: Route53AliasParams;
}

export function fieldsFromRoute53RecordParams(params: Route53RecordParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "zone_id", params.zone_id, TF.stringAliasValue);
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "ttl", params.ttl, TF.stringValue);
  TF.addOptionalField(fields, "records", params.records, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "alias", params.alias, (v) => TF.mapValue(fieldsFromRoute53AliasParams(v)));
  return fields;
}

export interface Route53AliasParams {
  name: string;
  zone_id: AT.HostedZoneId;
  evaluate_target_health: boolean;
}

export function fieldsFromRoute53AliasParams(params: Route53AliasParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "zone_id", params.zone_id, TF.stringAliasValue);
  TF.addField(fields, "evaluate_target_health", params.evaluate_target_health, TF.booleanValue);
  return fields;
}

export interface BucketVersioningParams {
  enabled?: boolean;
  mfa_delete?: boolean;
}

export function fieldsFromBucketVersioningParams(params: BucketVersioningParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addOptionalField(fields, "mfa_delete", params.mfa_delete, TF.booleanValue);
  return fields;
}

export interface ExpirationParams {
  days?: number;
  date?: string;
  expired_object_delete_marker?: boolean;
}

export function fieldsFromExpirationParams(params: ExpirationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "days", params.days, TF.numberValue);
  TF.addOptionalField(fields, "date", params.date, TF.stringValue);
  TF.addOptionalField(fields, "expired_object_delete_marker", params.expired_object_delete_marker, TF.booleanValue);
  return fields;
}

export interface LifecycleRuleParams {
  id?: string;
  prefix: string;
  enabled: boolean;
  expiration?: ExpirationParams;
}

export function fieldsFromLifecycleRuleParams(params: LifecycleRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "id", params.id, TF.stringValue);
  TF.addField(fields, "prefix", params.prefix, TF.stringValue);
  TF.addField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addOptionalField(fields, "expiration", params.expiration, (v) => TF.mapValue(fieldsFromExpirationParams(v)));
  return fields;
}

export interface CorsRuleParams {
  allowed_headers?: string[];
  allowed_methods: string[];
  allowed_origins: string[];
  expose_headers?: string[];
  max_age_seconds?: number;
}

export function fieldsFromCorsRuleParams(params: CorsRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "allowed_headers", params.allowed_headers, TF.listValue(TF.stringValue));
  TF.addField(fields, "allowed_methods", params.allowed_methods, TF.listValue(TF.stringValue));
  TF.addField(fields, "allowed_origins", params.allowed_origins, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "expose_headers", params.expose_headers, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "max_age_seconds", params.max_age_seconds, TF.numberValue);
  return fields;
}

export interface S3BucketParams {
  bucket: string;
  acl?: AT.CannedAcl;
  policy?: string;
  versioning?: BucketVersioningParams;
  lifecycle_rule?: LifecycleRuleParams;
  cors_rule?: CorsRuleParams;
  website?: WebsiteParams;
  tags?: TF.TagsMap;
}

export function fieldsFromS3BucketParams(params: S3BucketParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addOptionalField(fields, "acl", params.acl, TF.stringAliasValue);
  TF.addOptionalField(fields, "policy", params.policy, TF.stringValue);
  TF.addOptionalField(fields, "versioning", params.versioning, (v) => TF.mapValue(fieldsFromBucketVersioningParams(v)));
  TF.addOptionalField(fields, "lifecycle_rule", params.lifecycle_rule, (v) => TF.mapValue(fieldsFromLifecycleRuleParams(v)));
  TF.addOptionalField(fields, "cors_rule", params.cors_rule, (v) => TF.mapValue(fieldsFromCorsRuleParams(v)));
  TF.addOptionalField(fields, "website", params.website, (v) => TF.mapValue(fieldsFromWebsiteParams(v)));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface WebsiteParams {
  index_document?: string;
  error_document?: string;
  redirect_all_requests_to?: string;
  routing_rules?: string;
}

export function fieldsFromWebsiteParams(params: WebsiteParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "index_document", params.index_document, TF.stringValue);
  TF.addOptionalField(fields, "error_document", params.error_document, TF.stringValue);
  TF.addOptionalField(fields, "redirect_all_requests_to", params.redirect_all_requests_to, TF.stringValue);
  TF.addOptionalField(fields, "routing_rules", params.routing_rules, TF.stringValue);
  return fields;
}

export interface S3BucketObjectParams {
  bucket: string;
  key: string;
  source?: string;
  content?: string;
}

export function fieldsFromS3BucketObjectParams(params: S3BucketObjectParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addField(fields, "key", params.key, TF.stringValue);
  TF.addOptionalField(fields, "source", params.source, TF.stringValue);
  TF.addOptionalField(fields, "content", params.content, TF.stringValue);
  return fields;
}

export interface SnsTopicParams {
  name: string;
  display_name?: string;
}

export function fieldsFromSnsTopicParams(params: SnsTopicParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "display_name", params.display_name, TF.stringValue);
  return fields;
}

export interface IamUserParams {
  name: string;
  path?: string;
  force_destroy?: boolean;
}

export function fieldsFromIamUserParams(params: IamUserParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "force_destroy", params.force_destroy, TF.booleanValue);
  return fields;
}

export interface IamUserPolicyParams {
  name: string;
  policy: string;
  user: string;
}

export function fieldsFromIamUserPolicyParams(params: IamUserPolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  TF.addField(fields, "user", params.user, TF.stringValue);
  return fields;
}

export interface IamUserPolicyAttachmentParams {
  user: string;
  policy_arn: AT.Arn;
}

export function fieldsFromIamUserPolicyAttachmentParams(params: IamUserPolicyAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "user", params.user, TF.stringValue);
  TF.addField(fields, "policy_arn", params.policy_arn, TF.stringAliasValue);
  return fields;
}

export interface EcrRepositoryParams {
  name: string;
}

export function fieldsFromEcrRepositoryParams(params: EcrRepositoryParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  return fields;
}

export interface DbSubnetGroupParams {
  name: string;
  description?: string;
  subnet_ids: SubnetId[];
  tags?: TF.TagsMap;
}

export function fieldsFromDbSubnetGroupParams(params: DbSubnetGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface CloudwatchMetricAlarmParams {
  alarm_name: string;
  comparison_operator: 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
  evaluation_periods: number;
  metric_name: string;
  namespace: string;
  period: number;
  statistic: 'SampleCount' | 'Average' | 'Sum' | 'Minimum' | 'Maximum';
  threshold: number;
  actions_enabled?: boolean;
  alarm_actions?: AT.Arn[];
  alarm_description?: string;
  dimensions?: TF.TagsMap;
  insufficient_data_actions?: AT.Arn[];
  ok_actions?: AT.Arn[];
  unit?: string;
}

export function fieldsFromCloudwatchMetricAlarmParams(params: CloudwatchMetricAlarmParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "alarm_name", params.alarm_name, TF.stringValue);
  TF.addField(fields, "comparison_operator", params.comparison_operator, TF.stringValue);
  TF.addField(fields, "evaluation_periods", params.evaluation_periods, TF.numberValue);
  TF.addField(fields, "metric_name", params.metric_name, TF.stringValue);
  TF.addField(fields, "namespace", params.namespace, TF.stringValue);
  TF.addField(fields, "period", params.period, TF.numberValue);
  TF.addField(fields, "statistic", params.statistic, TF.stringValue);
  TF.addField(fields, "threshold", params.threshold, TF.numberValue);
  TF.addOptionalField(fields, "actions_enabled", params.actions_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "alarm_actions", params.alarm_actions, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "alarm_description", params.alarm_description, TF.stringValue);
  TF.addOptionalField(fields, "dimensions", params.dimensions, TF.tagsValue);
  TF.addOptionalField(fields, "insufficient_data_actions", params.insufficient_data_actions, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "ok_actions", params.ok_actions, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "unit", params.unit, TF.stringValue);
  return fields;
}

export interface IamInstanceProfileParams {
  name?: string;
  name_prefix?: string;
  path?: string;
  roles?: string[];
  role?: string;
}

export function fieldsFromIamInstanceProfileParams(params: IamInstanceProfileParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "roles", params.roles, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "role", params.role, TF.stringValue);
  return fields;
}

export interface IamRoleParams {
  name?: string;
  name_prefix?: string;
  assume_role_policy: string;
  path?: string;
}

export function fieldsFromIamRoleParams(params: IamRoleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "assume_role_policy", params.assume_role_policy, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  return fields;
}

export interface IamRolePolicyParams {
  name: string;
  policy: string;
  role: IamRoleId;
}

export function fieldsFromIamRolePolicyParams(params: IamRolePolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  TF.addField(fields, "role", params.role, TF.resourceIdValue);
  return fields;
}

export interface SqsQueueParams {
  name?: string;
  name_prefix?: string;
  visibility_timeout_seconds?: number;
  message_retention_seconds ?: number;
  max_message_size?: number;
  delay_seconds?: number;
  receive_wait_time_seconds?: number;
  policy?: string;
  redrive_policy?: string;
  fifo_queue?: boolean;
  content_based_deduplication?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromSqsQueueParams(params: SqsQueueParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "visibility_timeout_seconds", params.visibility_timeout_seconds, TF.numberValue);
  TF.addOptionalField(fields, "message_retention_seconds ", params.message_retention_seconds , TF.numberValue);
  TF.addOptionalField(fields, "max_message_size", params.max_message_size, TF.numberValue);
  TF.addOptionalField(fields, "delay_seconds", params.delay_seconds, TF.numberValue);
  TF.addOptionalField(fields, "receive_wait_time_seconds", params.receive_wait_time_seconds, TF.numberValue);
  TF.addOptionalField(fields, "policy", params.policy, TF.stringValue);
  TF.addOptionalField(fields, "redrive_policy", params.redrive_policy, TF.stringValue);
  TF.addOptionalField(fields, "fifo_queue", params.fifo_queue, TF.booleanValue);
  TF.addOptionalField(fields, "content_based_deduplication", params.content_based_deduplication, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SqsQueuePolicyParams {
  queue_url: string;
  policy: string;
}

export function fieldsFromSqsQueuePolicyParams(params: SqsQueuePolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "queue_url", params.queue_url, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  return fields;
}

export interface LbParams {
  name?: string;
  name_prefix?: string;
  internal?: boolean;
  load_balancer_type?: 'application' | 'network';
  security_groups?: SecurityGroupId[];
  access_logs?: LbAccessLogsParams;
  subnets?: SubnetId[];
  subnet_mapping?: LbSubnetMappingParams[];
  idle_timeout?: number;
  enable_deletion_protection?: boolean;
  enable_cross_zone_load_balancing?: boolean;
  enable_http2?: boolean;
  ip_address_type?: 'ipv4' | 'dualstack';
  tags?: TF.TagsMap;
}

export function fieldsFromLbParams(params: LbParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "internal", params.internal, TF.booleanValue);
  TF.addOptionalField(fields, "load_balancer_type", params.load_balancer_type, TF.stringValue);
  TF.addOptionalField(fields, "security_groups", params.security_groups, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "access_logs", params.access_logs, (v) => TF.mapValue(fieldsFromLbAccessLogsParams(v)));
  TF.addOptionalField(fields, "subnets", params.subnets, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "subnet_mapping", params.subnet_mapping, TF.listValue((v) => TF.mapValue(fieldsFromLbSubnetMappingParams(v))));
  TF.addOptionalField(fields, "idle_timeout", params.idle_timeout, TF.numberValue);
  TF.addOptionalField(fields, "enable_deletion_protection", params.enable_deletion_protection, TF.booleanValue);
  TF.addOptionalField(fields, "enable_cross_zone_load_balancing", params.enable_cross_zone_load_balancing, TF.booleanValue);
  TF.addOptionalField(fields, "enable_http2", params.enable_http2, TF.booleanValue);
  TF.addOptionalField(fields, "ip_address_type", params.ip_address_type, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface LbAccessLogsParams {
  bucket: string;
  bucket_prefix?: string;
  interval?: number;
  enabled?: boolean;
}

export function fieldsFromLbAccessLogsParams(params: LbAccessLogsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addOptionalField(fields, "bucket_prefix", params.bucket_prefix, TF.stringValue);
  TF.addOptionalField(fields, "interval", params.interval, TF.numberValue);
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  return fields;
}

export interface LbSubnetMappingParams {
  subnet_id: SubnetId;
  allocation_id: EipId;
}

export function fieldsFromLbSubnetMappingParams(params: LbSubnetMappingParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  TF.addField(fields, "allocation_id", params.allocation_id, TF.resourceIdValue);
  return fields;
}

export interface LbListenerParams {
  load_balancer_arn: AT.ArnT<"Lb">;
  port: number;
  protocol?: 'TCP' | 'HTTP' | 'HTTPS';
  ssl_policy?: string;
  certificate_arn?: AT.ArnT<"AcmCertificate">;
  default_action: LbListenerActionParams;
}

export function fieldsFromLbListenerParams(params: LbListenerParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "load_balancer_arn", params.load_balancer_arn, TF.resourceArnValue);
  TF.addField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addOptionalField(fields, "ssl_policy", params.ssl_policy, TF.stringValue);
  TF.addOptionalField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  TF.addField(fields, "default_action", params.default_action, (v) => TF.mapValue(fieldsFromLbListenerActionParams(v)));
  return fields;
}

export interface LbListenerActionParams {
  target_group_arn: AT.ArnT<"LbTargetGroup">;
  type: 'forward';
}

export function fieldsFromLbListenerActionParams(params: LbListenerActionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "target_group_arn", params.target_group_arn, TF.resourceArnValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface LbTargetGroupParams {
  name?: string;
  name_prefix?: string;
  port: number;
  protocol: 'TCP' | 'HTTP' | 'HTTPS';
  vpc_id: VpcId;
  deregistration_delay?: number;
  slow_start?: number;
  proxy_protocol_v2?: boolean;
  stickiness?: LbTargetGroupStickinessParams;
  health_check?: LbTargetGroupHealthCheckParams;
  target_type?: 'instance' | 'ip';
  tags?: TF.TagsMap;
}

export function fieldsFromLbTargetGroupParams(params: LbTargetGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "port", params.port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "deregistration_delay", params.deregistration_delay, TF.numberValue);
  TF.addOptionalField(fields, "slow_start", params.slow_start, TF.numberValue);
  TF.addOptionalField(fields, "proxy_protocol_v2", params.proxy_protocol_v2, TF.booleanValue);
  TF.addOptionalField(fields, "stickiness", params.stickiness, (v) => TF.mapValue(fieldsFromLbTargetGroupStickinessParams(v)));
  TF.addOptionalField(fields, "health_check", params.health_check, (v) => TF.mapValue(fieldsFromLbTargetGroupHealthCheckParams(v)));
  TF.addOptionalField(fields, "target_type", params.target_type, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface LbTargetGroupHealthCheckParams {
  interval?: number;
  path?: string;
  port?: string;
  protocol?: 'TCP' | 'HTTP' | 'HTTPS';
  timeout?: number;
  healthy_threshold?: number;
  unhealthy_threshold?: number;
  matcher?: string;
}

export function fieldsFromLbTargetGroupHealthCheckParams(params: LbTargetGroupHealthCheckParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "interval", params.interval, TF.numberValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.stringValue);
  TF.addOptionalField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addOptionalField(fields, "timeout", params.timeout, TF.numberValue);
  TF.addOptionalField(fields, "healthy_threshold", params.healthy_threshold, TF.numberValue);
  TF.addOptionalField(fields, "unhealthy_threshold", params.unhealthy_threshold, TF.numberValue);
  TF.addOptionalField(fields, "matcher", params.matcher, TF.stringValue);
  return fields;
}

export interface LbTargetGroupStickinessParams {
  type: 'lb_cookie';
  cookie_duration?: number;
  enabled?: boolean;
}

export function fieldsFromLbTargetGroupStickinessParams(params: LbTargetGroupStickinessParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "cookie_duration", params.cookie_duration, TF.numberValue);
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  return fields;
}

export interface LbTargetGroupAttachmentParams {
  target_group_arn: AT.ArnT<"LbTargetGroup">;
  target_id: string;
  port?: number;
  availability_zone?: AT.AvailabilityZone;
}

export function fieldsFromLbTargetGroupAttachmentParams(params: LbTargetGroupAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "target_group_arn", params.target_group_arn, TF.resourceArnValue);
  TF.addField(fields, "target_id", params.target_id, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  return fields;
}

export interface LbListenerRuleParams {
  listener_arn: AT.ArnT<"LbListener">;
  priority?: number;
  action: LbListenerActionParams;
  condition: LbListenerRuleConditionParams;
}

export function fieldsFromLbListenerRuleParams(params: LbListenerRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "listener_arn", params.listener_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "priority", params.priority, TF.numberValue);
  TF.addField(fields, "action", params.action, (v) => TF.mapValue(fieldsFromLbListenerActionParams(v)));
  TF.addField(fields, "condition", params.condition, (v) => TF.mapValue(fieldsFromLbListenerRuleConditionParams(v)));
  return fields;
}

export interface LbListenerRuleConditionParams {
  field: 'path-pattern' | 'host-header';
  values: string[];
}

export function fieldsFromLbListenerRuleConditionParams(params: LbListenerRuleConditionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "field", params.field, TF.stringValue);
  TF.addField(fields, "values", params.values, TF.listValue(TF.stringValue));
  return fields;
}

export interface CloudwatchLogGroupParams {
  name?: string;
  name_prefix?: string;
  retention_in_days?: number;
  tags?: TF.TagsMap;
}

export function fieldsFromCloudwatchLogGroupParams(params: CloudwatchLogGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "retention_in_days", params.retention_in_days, TF.numberValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface AwsParams {
  region?: AT.Region;
}

export function fieldsFromAwsParams(params: AwsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "region", params.region, TF.stringAliasValue);
  return fields;
}

export interface ElasticsearchDomainParams {
  domain_name: string;
  access_policies?: string;
  advanced_options?: TF.TagsMap;
  ebs_options?: ElasticsearchDomainEbsOptionsParams;
  cluster_config?: ElasticsearchDomainClusterConfigParams;
  snapshot_options?: ElasticsearchDomainSnapshotOptionsParams;
  elasticsearch_version?: string;
  tags?: TF.TagsMap;
}

export function fieldsFromElasticsearchDomainParams(params: ElasticsearchDomainParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "access_policies", params.access_policies, TF.stringValue);
  TF.addOptionalField(fields, "advanced_options", params.advanced_options, TF.tagsValue);
  TF.addOptionalField(fields, "ebs_options", params.ebs_options, (v) => TF.mapValue(fieldsFromElasticsearchDomainEbsOptionsParams(v)));
  TF.addOptionalField(fields, "cluster_config", params.cluster_config, (v) => TF.mapValue(fieldsFromElasticsearchDomainClusterConfigParams(v)));
  TF.addOptionalField(fields, "snapshot_options", params.snapshot_options, (v) => TF.mapValue(fieldsFromElasticsearchDomainSnapshotOptionsParams(v)));
  TF.addOptionalField(fields, "elasticsearch_version", params.elasticsearch_version, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface ElasticsearchDomainClusterConfigParams {
  instance_type?: AT.EsInstanceType;
  instance_count?: number;
  dedicated_master_enabled?: boolean;
  dedicated_master_type?: AT.EsInstanceType;
  dedicated_master_count?: number;
  zone_awareness_enabled?: boolean;
}

export function fieldsFromElasticsearchDomainClusterConfigParams(params: ElasticsearchDomainClusterConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "instance_type", params.instance_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "instance_count", params.instance_count, TF.numberValue);
  TF.addOptionalField(fields, "dedicated_master_enabled", params.dedicated_master_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "dedicated_master_type", params.dedicated_master_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "dedicated_master_count", params.dedicated_master_count, TF.numberValue);
  TF.addOptionalField(fields, "zone_awareness_enabled", params.zone_awareness_enabled, TF.booleanValue);
  return fields;
}

export interface ElasticsearchDomainEbsOptionsParams {
  ebs_enabled: boolean;
  volume_type?: string;
  volume_size?: number;
  iops?: number;
}

export function fieldsFromElasticsearchDomainEbsOptionsParams(params: ElasticsearchDomainEbsOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "ebs_enabled", params.ebs_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "volume_type", params.volume_type, TF.stringValue);
  TF.addOptionalField(fields, "volume_size", params.volume_size, TF.numberValue);
  TF.addOptionalField(fields, "iops", params.iops, TF.numberValue);
  return fields;
}

export interface ElasticsearchDomainSnapshotOptionsParams {
  automated_snapshot_start_hour: number;
}

export function fieldsFromElasticsearchDomainSnapshotOptionsParams(params: ElasticsearchDomainSnapshotOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "automated_snapshot_start_hour", params.automated_snapshot_start_hour, TF.numberValue);
  return fields;
}

export interface ElasticsearchDomainPolicyParams {
  domain_name: string;
  access_policies?: string;
}

export function fieldsFromElasticsearchDomainPolicyParams(params: ElasticsearchDomainPolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "access_policies", params.access_policies, TF.stringValue);
  return fields;
}

export interface AcmCertificateParams {
  domain_name: string;
  subject_alternative_names?: string[];
  validation_method: string;
  tags?: TF.TagsMap;
}

export function fieldsFromAcmCertificateParams(params: AcmCertificateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "subject_alternative_names", params.subject_alternative_names, TF.listValue(TF.stringValue));
  TF.addField(fields, "validation_method", params.validation_method, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface AcmCertificateValidationParams {
  certificate_arn: AT.ArnT<"AcmCertificate">;
  validation_record_fqdns?: string[];
}

export function fieldsFromAcmCertificateValidationParams(params: AcmCertificateValidationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "validation_record_fqdns", params.validation_record_fqdns, TF.listValue(TF.stringValue));
  return fields;
}

export interface LbListenerCertificateParams {
  listener_arn: AT.ArnT<"LbListener">;
  certificate_arn: AT.ArnT<"AcmCertificate">;
}

export function fieldsFromLbListenerCertificateParams(params: LbListenerCertificateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "listener_arn", params.listener_arn, TF.resourceArnValue);
  TF.addField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  return fields;
}

export interface LaunchConfigurationParams {
  name?: string;
  name_prefix?: string;
  image_id: AT.Ami;
  instance_type: AT.InstanceType;
  iam_instance_profile?: IamInstanceProfileId;
  key_name?: AT.KeyName;
  security_groups?: SecurityGroupId[];
  associate_public_ip_address?: boolean;
  user_data?: string;
  enable_monitoring?: boolean;
  ebs_optimized?: boolean;
  root_block_device?: InstanceRootBlockDeviceParams;
}

export function fieldsFromLaunchConfigurationParams(params: LaunchConfigurationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "image_id", params.image_id, TF.stringAliasValue);
  TF.addField(fields, "instance_type", params.instance_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "iam_instance_profile", params.iam_instance_profile, TF.resourceIdValue);
  TF.addOptionalField(fields, "key_name", params.key_name, TF.stringAliasValue);
  TF.addOptionalField(fields, "security_groups", params.security_groups, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "associate_public_ip_address", params.associate_public_ip_address, TF.booleanValue);
  TF.addOptionalField(fields, "user_data", params.user_data, TF.stringValue);
  TF.addOptionalField(fields, "enable_monitoring", params.enable_monitoring, TF.booleanValue);
  TF.addOptionalField(fields, "ebs_optimized", params.ebs_optimized, TF.booleanValue);
  TF.addOptionalField(fields, "root_block_device", params.root_block_device, (v) => TF.mapValue(fieldsFromInstanceRootBlockDeviceParams(v)));
  return fields;
}

export interface CloudwatchLoggingOptionsParams {
  enabled?: boolean;
  log_group_name?: string;
  log_stream_name?: string;
}

export function fieldsFromCloudwatchLoggingOptionsParams(params: CloudwatchLoggingOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addOptionalField(fields, "log_group_name", params.log_group_name, TF.stringValue);
  TF.addOptionalField(fields, "log_stream_name", params.log_stream_name, TF.stringValue);
  return fields;
}

export interface ExtendedS3ConfigurationParams {
  role_arn: AT.ArnT<"IamRole">;
  bucket_arn: AT.ArnT<"S3Bucket">;
  buffer_size?: number;
  buffer_interval?: number;
  cloudwatch_logging_options?: CloudwatchLoggingOptionsParams;
}

export function fieldsFromExtendedS3ConfigurationParams(params: ExtendedS3ConfigurationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "role_arn", params.role_arn, TF.resourceArnValue);
  TF.addField(fields, "bucket_arn", params.bucket_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "buffer_size", params.buffer_size, TF.numberValue);
  TF.addOptionalField(fields, "buffer_interval", params.buffer_interval, TF.numberValue);
  TF.addOptionalField(fields, "cloudwatch_logging_options", params.cloudwatch_logging_options, (v) => TF.mapValue(fieldsFromCloudwatchLoggingOptionsParams(v)));
  return fields;
}

export interface KinesisFirehoseDeliveryStreamParams {
  name: string;
  destination: 'extended_s3' | 'redshift' | 'elasticsearch' | 'splunk';
  extended_s3_configuration?: ExtendedS3ConfigurationParams;
  tags?: TF.TagsMap;
}

export function fieldsFromKinesisFirehoseDeliveryStreamParams(params: KinesisFirehoseDeliveryStreamParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "destination", params.destination, TF.stringValue);
  TF.addOptionalField(fields, "extended_s3_configuration", params.extended_s3_configuration, (v) => TF.mapValue(fieldsFromExtendedS3ConfigurationParams(v)));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface S3BucketMetricParams {
  bucket: string;
  name: string;
}

export function fieldsFromS3BucketMetricParams(params: S3BucketMetricParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addField(fields, "name", params.name, TF.stringValue);
  return fields;
}

export interface ElasticacheParameterGroupParams {
  name: string;
  family: string;
  description?: string;
}

export function fieldsFromElasticacheParameterGroupParams(params: ElasticacheParameterGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "family", params.family, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface ElasticacheClusterParams {
  cluster_id: string;
  engine: 'memcached' | 'redis';
  node_type: AT.CacheNodeType;
  num_cache_nodes: number;
  parameter_group_name: AT.ElasticacheParameterGroupName;
  port?: number;
}

export function fieldsFromElasticacheClusterParams(params: ElasticacheClusterParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "cluster_id", params.cluster_id, TF.stringValue);
  TF.addField(fields, "engine", params.engine, TF.stringValue);
  TF.addField(fields, "node_type", params.node_type, TF.stringAliasValue);
  TF.addField(fields, "num_cache_nodes", params.num_cache_nodes, TF.numberValue);
  TF.addField(fields, "parameter_group_name", params.parameter_group_name, TF.stringAliasValue);
  TF.addOptionalField(fields, "port", params.port, TF.numberValue);
  return fields;
}

export interface FieldToMatchParams {
  data?: string;
  type: 'HEADER' | 'METHOD' | 'QUERY_STRING' | 'URI' | 'BODY' | 'SINGLE_QUERY_ARG' | 'ALL_QUERY_ARGS';
}

export function fieldsFromFieldToMatchParams(params: FieldToMatchParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "data", params.data, TF.stringValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface ByteMatchTuplesParams {
  field_to_match: FieldToMatchParams;
  positional_constraint: AT.PositionalConstraint;
  target_string?: string;
}

export function fieldsFromByteMatchTuplesParams(params: ByteMatchTuplesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "field_to_match", params.field_to_match, (v) => TF.mapValue(fieldsFromFieldToMatchParams(v)));
  TF.addField(fields, "positional_constraint", params.positional_constraint, TF.stringAliasValue);
  TF.addOptionalField(fields, "target_string", params.target_string, TF.stringValue);
  return fields;
}

export interface WafByteMatchSetParams {
  name: string;
  byte_match_tuples: ByteMatchTuplesParams;
}

export function fieldsFromWafByteMatchSetParams(params: WafByteMatchSetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "byte_match_tuples", params.byte_match_tuples, (v) => TF.mapValue(fieldsFromByteMatchTuplesParams(v)));
  return fields;
}

export interface IpSetDescriptorsParams {
  type: 'IPV4' | 'IPV6';
  value: string;
}

export function fieldsFromIpSetDescriptorsParams(params: IpSetDescriptorsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addField(fields, "value", params.value, TF.stringValue);
  return fields;
}

export interface WafIpsetParams {
  name: string;
  ip_set_descriptors: IpSetDescriptorsParams;
}

export function fieldsFromWafIpsetParams(params: WafIpsetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "ip_set_descriptors", params.ip_set_descriptors, (v) => TF.mapValue(fieldsFromIpSetDescriptorsParams(v)));
  return fields;
}

export interface WafregionalRegexPatternSetParams {
  name: string;
  regex_pattern_strings?: string[];
}

export function fieldsFromWafregionalRegexPatternSetParams(params: WafregionalRegexPatternSetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "regex_pattern_strings", params.regex_pattern_strings, TF.listValue(TF.stringValue));
  return fields;
}

export interface RegexMatchTupleParams {
  field_to_match: FieldToMatchParams;
  regex_pattern_set_id: WafregionalRegexPatternSetId;
  text_transformation: AT.TextTransformation;
}

export function fieldsFromRegexMatchTupleParams(params: RegexMatchTupleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "field_to_match", params.field_to_match, (v) => TF.mapValue(fieldsFromFieldToMatchParams(v)));
  TF.addField(fields, "regex_pattern_set_id", params.regex_pattern_set_id, TF.resourceIdValue);
  TF.addField(fields, "text_transformation", params.text_transformation, TF.stringAliasValue);
  return fields;
}

export interface WafregionalRegexMatchSetParams {
  name: string;
  regex_match_tuple: RegexMatchTupleParams;
}

export function fieldsFromWafregionalRegexMatchSetParams(params: WafregionalRegexMatchSetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "regex_match_tuple", params.regex_match_tuple, (v) => TF.mapValue(fieldsFromRegexMatchTupleParams(v)));
  return fields;
}

export interface WafregionalIpsetParams {
  name: string;
  ip_set_descriptor?: IpSetDescriptorsParams[];
}

export function fieldsFromWafregionalIpsetParams(params: WafregionalIpsetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "ip_set_descriptor", params.ip_set_descriptor, TF.listValue((v) => TF.mapValue(fieldsFromIpSetDescriptorsParams(v))));
  return fields;
}
